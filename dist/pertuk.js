const X="ENTRIES",J="KEYS",U="VALUES";class T{constructor(t,e){const n=t._tree,s=Array.from(n.keys());this.set=t,this._type=e,this._path=s.length>0?[{node:n,keys:s}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:e}=x(this._path);if(x(e)==="")return{done:!1,value:this.result()};const n=t.get(x(e));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=x(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>x(t)).filter(t=>t!=="").join("")}value(){return x(this._path).node.get("")}result(){switch(this._type){case U:return this.value();case J:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const x=o=>o[o.length-1],Z=(o,t,e)=>{const n=new Map;if(t===void 0)return n;const s=t.length+1,i=s+e,c=new Uint8Array(i*s).fill(e+1);for(let d=0;d<s;++d)c[d]=d;for(let d=1;d<i;++d)c[d*s]=d;return q(o,t,e,n,c,1,s,""),n},q=(o,t,e,n,s,i,c,d)=>{const l=i*c;t:for(const r of o.keys())if(r===""){const a=s[l-1];a<=e&&n.set(d,[o.get(r),a])}else{let a=i;for(let u=0;u<r.length;++u,++a){const h=r[u],f=c*a,p=f-c;let g=s[f];const m=Math.max(0,a-e-1),_=Math.min(c-1,a+e);for(let w=m;w<_;++w){const z=h!==t[w],E=s[p+w]+ +z,L=s[p+w+1]+1,v=s[f+w]+1,S=s[f+w+1]=Math.min(E,L,v);S<g&&(g=S)}if(g>e)continue t}q(o.get(r),t,e,n,s,a,c,d+r)}};class y{constructor(t=new Map,e=""){this._size=void 0,this._tree=t,this._prefix=e}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[e,n]=F(this._tree,t.slice(this._prefix.length));if(e===void 0){const[s,i]=$(n);for(const c of s.keys())if(c!==""&&c.startsWith(i)){const d=new Map;return d.set(c.slice(i.length),s.get(c)),new y(d,t)}}return new y(e,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,tt(this._tree,t)}entries(){return new T(this,X)}forEach(t){for(const[e,n]of this)t(e,n,this)}fuzzyGet(t,e){return Z(this._tree,t,e)}get(t){const e=V(this._tree,t);return e!==void 0?e.get(""):void 0}has(t){const e=V(this._tree,t);return e!==void 0&&e.has("")}keys(){return new T(this,J)}set(t,e){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,C(this._tree,t).set("",e),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=C(this._tree,t);return n.set("",e(n.get(""))),this}fetch(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=C(this._tree,t);let s=n.get("");return s===void 0&&n.set("",s=e()),s}values(){return new T(this,U)}[Symbol.iterator](){return this.entries()}static from(t){const e=new y;for(const[n,s]of t)e.set(n,s);return e}static fromObject(t){return y.from(Object.entries(t))}}const F=(o,t,e=[])=>{if(t.length===0||o==null)return[o,e];for(const n of o.keys())if(n!==""&&t.startsWith(n))return e.push([o,n]),F(o.get(n),t.slice(n.length),e);return e.push([o,t]),F(void 0,"",e)},V=(o,t)=>{if(t.length===0||o==null)return o;for(const e of o.keys())if(e!==""&&t.startsWith(e))return V(o.get(e),t.slice(e.length))},C=(o,t)=>{const e=t.length;t:for(let n=0;o&&n<e;){for(const i of o.keys())if(i!==""&&t[n]===i[0]){const c=Math.min(e-n,i.length);let d=1;for(;d<c&&t[n+d]===i[d];)++d;const l=o.get(i);if(d===i.length)o=l;else{const r=new Map;r.set(i.slice(d),l),o.set(t.slice(n,n+d),r),o.delete(i),o=r}n+=d;continue t}const s=new Map;return o.set(t.slice(n),s),s}return o},tt=(o,t)=>{const[e,n]=F(o,t);if(e!==void 0){if(e.delete(""),e.size===0)K(n);else if(e.size===1){const[s,i]=e.entries().next().value;Q(n,s,i)}}},K=o=>{if(o.length===0)return;const[t,e]=$(o);if(t.delete(e),t.size===0)K(o.slice(0,-1));else if(t.size===1){const[n,s]=t.entries().next().value;n!==""&&Q(o.slice(0,-1),n,s)}},Q=(o,t,e)=>{if(o.length===0)return;const[n,s]=$(o);n.set(s+t,e),n.delete(s)},$=o=>o[o.length-1],B="or",G="and",et="and_not";class k{constructor(t){if(t?.fields==null)throw new Error('MiniSearch: option "fields" must be provided');const e=t.autoVacuum==null||t.autoVacuum===!0?O:t.autoVacuum;this._options={...A,...t,autoVacuum:e,searchOptions:{...N,...t.searchOptions||{}},autoSuggestOptions:{...rt,...t.autoSuggestOptions||{}}},this._index=new y,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=j,this.addFields(this._options.fields)}add(t){const{extractField:e,stringifyField:n,tokenize:s,processTerm:i,fields:c,idField:d}=this._options,l=e(t,d);if(l==null)throw new Error(`MiniSearch: document does not have ID field "${d}"`);if(this._idToShortId.has(l))throw new Error(`MiniSearch: duplicate ID ${l}`);const r=this.addDocumentId(l);this.saveStoredFields(r,t);for(const a of c){const u=e(t,a);if(u==null)continue;const h=s(n(u,a),a),f=this._fieldIds[a],p=new Set(h).size;this.addFieldLength(r,f,this._documentCount-1,p);for(const g of h){const m=i(g,a);if(Array.isArray(m))for(const _ of m)this.addTerm(f,r,_);else m&&this.addTerm(f,r,m)}}}addAll(t){for(const e of t)this.add(e)}addAllAsync(t,e={}){const{chunkSize:n=10}=e,s={chunk:[],promise:Promise.resolve()},{chunk:i,promise:c}=t.reduce(({chunk:d,promise:l},r,a)=>(d.push(r),(a+1)%n===0?{chunk:[],promise:l.then(()=>new Promise(u=>setTimeout(u,0))).then(()=>this.addAll(d))}:{chunk:d,promise:l}),s);return c.then(()=>this.addAll(i))}remove(t){const{tokenize:e,processTerm:n,extractField:s,stringifyField:i,fields:c,idField:d}=this._options,l=s(t,d);if(l==null)throw new Error(`MiniSearch: document does not have ID field "${d}"`);const r=this._idToShortId.get(l);if(r==null)throw new Error(`MiniSearch: cannot remove document with ID ${l}: it is not in the index`);for(const a of c){const u=s(t,a);if(u==null)continue;const h=e(i(u,a),a),f=this._fieldIds[a],p=new Set(h).size;this.removeFieldLength(r,f,this._documentCount,p);for(const g of h){const m=n(g,a);if(Array.isArray(m))for(const _ of m)this.removeTerm(f,r,_);else m&&this.removeTerm(f,r,m)}}this._storedFields.delete(r),this._documentIds.delete(r),this._idToShortId.delete(l),this._fieldLength.delete(r),this._documentCount-=1}removeAll(t){if(t)for(const e of t)this.remove(e);else{if(arguments.length>0)throw new Error("Expected documents to be present. Omit the argument to remove all documents.");this._index=new y,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldLength=new Map,this._avgFieldLength=[],this._storedFields=new Map,this._nextId=0}}discard(t){const e=this._idToShortId.get(t);if(e==null)throw new Error(`MiniSearch: cannot discard document with ID ${t}: it is not in the index`);this._idToShortId.delete(t),this._documentIds.delete(e),this._storedFields.delete(e),(this._fieldLength.get(e)||[]).forEach((n,s)=>{this.removeFieldLength(e,s,this._documentCount,n)}),this._fieldLength.delete(e),this._documentCount-=1,this._dirtCount+=1,this.maybeAutoVacuum()}maybeAutoVacuum(){if(this._options.autoVacuum===!1)return;const{minDirtFactor:t,minDirtCount:e,batchSize:n,batchWait:s}=this._options.autoVacuum;this.conditionalVacuum({batchSize:n,batchWait:s},{minDirtCount:e,minDirtFactor:t})}discardAll(t){const e=this._options.autoVacuum;try{this._options.autoVacuum=!1;for(const n of t)this.discard(n)}finally{this._options.autoVacuum=e}this.maybeAutoVacuum()}replace(t){const{idField:e,extractField:n}=this._options,s=n(t,e);this.discard(s),this.add(t)}vacuum(t={}){return this.conditionalVacuum(t)}conditionalVacuum(t,e){return this._currentVacuum?(this._enqueuedVacuumConditions=this._enqueuedVacuumConditions&&e,this._enqueuedVacuum!=null?this._enqueuedVacuum:(this._enqueuedVacuum=this._currentVacuum.then(()=>{const n=this._enqueuedVacuumConditions;return this._enqueuedVacuumConditions=j,this.performVacuuming(t,n)}),this._enqueuedVacuum)):this.vacuumConditionsMet(e)===!1?Promise.resolve():(this._currentVacuum=this.performVacuuming(t),this._currentVacuum)}async performVacuuming(t,e){const n=this._dirtCount;if(this.vacuumConditionsMet(e)){const s=t.batchSize||D.batchSize,i=t.batchWait||D.batchWait;let c=1;for(const[d,l]of this._index){for(const[r,a]of l)for(const[u]of a)this._documentIds.has(u)||(a.size<=1?l.delete(r):a.delete(u));this._index.get(d).size===0&&this._index.delete(d),c%s===0&&await new Promise(r=>setTimeout(r,i)),c+=1}this._dirtCount-=n}await null,this._currentVacuum=this._enqueuedVacuum,this._enqueuedVacuum=null}vacuumConditionsMet(t){if(t==null)return!0;let{minDirtCount:e,minDirtFactor:n}=t;return e=e||O.minDirtCount,n=n||O.minDirtFactor,this.dirtCount>=e&&this.dirtFactor>=n}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}has(t){return this._idToShortId.has(t)}getStoredFields(t){const e=this._idToShortId.get(t);if(e!=null)return this._storedFields.get(e)}search(t,e={}){const{searchOptions:n}=this._options,s={...n,...e},i=this.executeQuery(t,e),c=[];for(const[d,{score:l,terms:r,match:a}]of i){const u=r.length||1,h={id:this._documentIds.get(d),score:l*u,terms:Object.keys(a),queryTerms:r,match:a};Object.assign(h,this._storedFields.get(d)),(s.filter==null||s.filter(h))&&c.push(h)}return t===k.wildcard&&s.boostDocument==null||c.sort(W),c}autoSuggest(t,e={}){e={...this._options.autoSuggestOptions,...e};const n=new Map;for(const{score:i,terms:c}of this.search(t,e)){const d=c.join(" "),l=n.get(d);l!=null?(l.score+=i,l.count+=1):n.set(d,{score:i,terms:c,count:1})}const s=[];for(const[i,{score:c,terms:d,count:l}]of n)s.push({suggestion:i,terms:d,score:c/l});return s.sort(W),s}get documentCount(){return this._documentCount}get termCount(){return this._index.size}static loadJSON(t,e){if(e==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJS(JSON.parse(t),e)}static async loadJSONAsync(t,e){if(e==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJSAsync(JSON.parse(t),e)}static getDefault(t){if(A.hasOwnProperty(t))return M(A,t);throw new Error(`MiniSearch: unknown option "${t}"`)}static loadJS(t,e){const{index:n,documentIds:s,fieldLength:i,storedFields:c,serializationVersion:d}=t,l=this.instantiateMiniSearch(t,e);l._documentIds=b(s),l._fieldLength=b(i),l._storedFields=b(c);for(const[r,a]of l._documentIds)l._idToShortId.set(a,r);for(const[r,a]of n){const u=new Map;for(const h of Object.keys(a)){let f=a[h];d===1&&(f=f.ds),u.set(parseInt(h,10),b(f))}l._index.set(r,u)}return l}static async loadJSAsync(t,e){const{index:n,documentIds:s,fieldLength:i,storedFields:c,serializationVersion:d}=t,l=this.instantiateMiniSearch(t,e);l._documentIds=await I(s),l._fieldLength=await I(i),l._storedFields=await I(c);for(const[a,u]of l._documentIds)l._idToShortId.set(u,a);let r=0;for(const[a,u]of n){const h=new Map;for(const f of Object.keys(u)){let p=u[f];d===1&&(p=p.ds),h.set(parseInt(f,10),await I(p))}++r%1e3===0&&await Y(0),l._index.set(a,h)}return l}static instantiateMiniSearch(t,e){const{documentCount:n,nextId:s,fieldIds:i,averageFieldLength:c,dirtCount:d,serializationVersion:l}=t;if(l!==1&&l!==2)throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");const r=new k(e);return r._documentCount=n,r._nextId=s,r._idToShortId=new Map,r._fieldIds=i,r._avgFieldLength=c,r._dirtCount=d||0,r._index=new y,r}executeQuery(t,e={}){if(t===k.wildcard)return this.executeWildcardQuery(e);if(typeof t!="string"){const h={...e,...t,queries:void 0},f=t.queries.map(p=>this.executeQuery(p,h));return this.combineResults(f,h.combineWith)}const{tokenize:n,processTerm:s,searchOptions:i}=this._options,c={tokenize:n,processTerm:s,...i,...e},{tokenize:d,processTerm:l}=c,u=d(t).flatMap(h=>l(h)).filter(h=>!!h).map(ot(c)).map(h=>this.executeQuerySpec(h,c));return this.combineResults(u,c.combineWith)}executeQuerySpec(t,e){const n={...this._options.searchOptions,...e},s=(n.fields||this._options.fields).reduce((g,m)=>({...g,[m]:M(n.boost,m)||1}),{}),{boostDocument:i,weights:c,maxFuzzy:d,bm25:l}=n,{fuzzy:r,prefix:a}={...N.weights,...c},u=this._index.get(t.term),h=this.termResults(t.term,t.term,1,t.termBoost,u,s,i,l);let f,p;if(t.prefix&&(f=this._index.atPrefix(t.term)),t.fuzzy){const g=t.fuzzy===!0?.2:t.fuzzy,m=g<1?Math.min(d,Math.round(t.term.length*g)):g;m&&(p=this._index.fuzzyGet(t.term,m))}if(f)for(const[g,m]of f){const _=g.length-t.term.length;if(!_)continue;p?.delete(g);const w=a*g.length/(g.length+.3*_);this.termResults(t.term,g,w,t.termBoost,m,s,i,l,h)}if(p)for(const g of p.keys()){const[m,_]=p.get(g);if(!_)continue;const w=r*g.length/(g.length+_);this.termResults(t.term,g,w,t.termBoost,m,s,i,l,h)}return h}executeWildcardQuery(t){const e=new Map,n={...this._options.searchOptions,...t};for(const[s,i]of this._documentIds){const c=n.boostDocument?n.boostDocument(i,"",this._storedFields.get(s)):1;e.set(s,{score:c,terms:[],match:{}})}return e}combineResults(t,e=B){if(t.length===0)return new Map;const n=e.toLowerCase(),s=nt[n];if(!s)throw new Error(`Invalid combination operator: ${e}`);return t.reduce(s)||new Map}toJSON(){const t=[];for(const[e,n]of this._index){const s={};for(const[i,c]of n)s[i]=Object.fromEntries(c);t.push([e,s])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}termResults(t,e,n,s,i,c,d,l,r=new Map){if(i==null)return r;for(const a of Object.keys(c)){const u=c[a],h=this._fieldIds[a],f=i.get(h);if(f==null)continue;let p=f.size;const g=this._avgFieldLength[h];for(const m of f.keys()){if(!this._documentIds.has(m)){this.removeTerm(h,m,e),p-=1;continue}const _=d?d(this._documentIds.get(m),e,this._storedFields.get(m)):1;if(!_)continue;const w=f.get(m),z=this._fieldLength.get(m)[h],E=it(w,p,this._documentCount,z,g,l),L=n*s*u*_*E,v=r.get(m);if(v){v.score+=L,ct(v.terms,t);const S=M(v.match,e);S?S.push(a):v.match[e]=[a]}else r.set(m,{score:L,terms:[t],match:{[e]:[a]}})}}return r}addTerm(t,e,n){const s=this._index.fetch(n,H);let i=s.get(t);if(i==null)i=new Map,i.set(e,1),s.set(t,i);else{const c=i.get(e);i.set(e,(c||0)+1)}}removeTerm(t,e,n){if(!this._index.has(n)){this.warnDocumentChanged(e,t,n);return}const s=this._index.fetch(n,H),i=s.get(t);i==null||i.get(e)==null?this.warnDocumentChanged(e,t,n):i.get(e)<=1?i.size<=1?s.delete(t):i.delete(e):i.set(e,i.get(e)-1),this._index.get(n).size===0&&this._index.delete(n)}warnDocumentChanged(t,e,n){for(const s of Object.keys(this._fieldIds))if(this._fieldIds[s]===e){this._options.logger("warn",`MiniSearch: document with ID ${this._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${s}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}}addDocumentId(t){const e=this._nextId;return this._idToShortId.set(t,e),this._documentIds.set(e,t),this._documentCount+=1,this._nextId+=1,e}addFields(t){for(let e=0;e<t.length;e++)this._fieldIds[t[e]]=e}addFieldLength(t,e,n,s){let i=this._fieldLength.get(t);i==null&&this._fieldLength.set(t,i=[]),i[e]=s;const d=(this._avgFieldLength[e]||0)*n+s;this._avgFieldLength[e]=d/(n+1)}removeFieldLength(t,e,n,s){if(n===1){this._avgFieldLength[e]=0;return}const i=this._avgFieldLength[e]*n-s;this._avgFieldLength[e]=i/(n-1)}saveStoredFields(t,e){const{storeFields:n,extractField:s}=this._options;if(n==null||n.length===0)return;let i=this._storedFields.get(t);i==null&&this._storedFields.set(t,i={});for(const c of n){const d=s(e,c);d!==void 0&&(i[c]=d)}}}k.wildcard=Symbol("*");const M=(o,t)=>Object.prototype.hasOwnProperty.call(o,t)?o[t]:void 0,nt={[B]:(o,t)=>{for(const e of t.keys()){const n=o.get(e);if(n==null)o.set(e,t.get(e));else{const{score:s,terms:i,match:c}=t.get(e);n.score=n.score+s,n.match=Object.assign(n.match,c),R(n.terms,i)}}return o},[G]:(o,t)=>{const e=new Map;for(const n of t.keys()){const s=o.get(n);if(s==null)continue;const{score:i,terms:c,match:d}=t.get(n);R(s.terms,c),e.set(n,{score:s.score+i,terms:s.terms,match:Object.assign(s.match,d)})}return e},[et]:(o,t)=>{for(const e of t.keys())o.delete(e);return o}},st={k:1.2,b:.7,d:.5},it=(o,t,e,n,s,i)=>{const{k:c,b:d,d:l}=i;return Math.log(1+(e-t+.5)/(t+.5))*(l+o*(c+1)/(o+c*(1-d+d*n/s)))},ot=o=>(t,e,n)=>{const s=typeof o.fuzzy=="function"?o.fuzzy(t,e,n):o.fuzzy||!1,i=typeof o.prefix=="function"?o.prefix(t,e,n):o.prefix===!0,c=typeof o.boostTerm=="function"?o.boostTerm(t,e,n):1;return{term:t,fuzzy:s,prefix:i,termBoost:c}},A={idField:"id",extractField:(o,t)=>o[t],stringifyField:(o,t)=>o.toString(),tokenize:o=>o.split(at),processTerm:o=>o.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(o,t)=>{typeof console?.[o]=="function"&&console[o](t)},autoVacuum:!0},N={combineWith:B,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:st},rt={combineWith:G,prefix:(o,t,e)=>t===e.length-1},D={batchSize:1e3,batchWait:10},j={minDirtFactor:.1,minDirtCount:20},O={...D,...j},ct=(o,t)=>{o.includes(t)||o.push(t)},R=(o,t)=>{for(const e of t)o.includes(e)||o.push(e)},W=({score:o},{score:t})=>t-o,H=()=>new Map,b=o=>{const t=new Map;for(const e of Object.keys(o))t.set(parseInt(e,10),o[e]);return t},I=async o=>{const t=new Map;let e=0;for(const n of Object.keys(o))t.set(parseInt(n,10),o[n]),++e%1e3===0&&await Y(0);return t},Y=o=>new Promise(t=>setTimeout(t,o)),at=/[\n\r\p{Z}\p{P}]+/u;class P{constructor(){this.init()}init(){this.initThemeToggle(),this.initSyntaxHighlighting(),this.initSearch(),this.initTableOfContents(),this.initKeyboardShortcuts(),this.initGlobalLanguageSelector()}initThemeToggle(){const t=document.getElementById("theme-toggle");if(!t)return;const e=localStorage.getItem("theme")||"light";this.applyTheme(e),t.addEventListener("click",()=>{const s=(localStorage.getItem("theme")||"light")==="dark"?"light":"dark";this.applyTheme(s),localStorage.setItem("theme",s)})}applyTheme(t){const e=document.documentElement;t==="dark"?e.classList.add("dark"):e.classList.remove("dark"),e.offsetHeight}initSyntaxHighlighting(){this.addCopyButtons()}addCopyButtons(){document.querySelectorAll("pre").forEach(t=>{const e=document.createElement("button");e.className="absolute top-2 right-2 p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition-colors rounded-md hover:bg-gray-100 dark:hover:bg-gray-800",e.innerHTML=`
                <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                </svg>
            `,e.title="Copy code",t.style.position="relative",t.appendChild(e),e.addEventListener("click",()=>{const n=t.querySelector("code");n&&(async()=>{try{if(navigator.clipboard&&navigator.clipboard.writeText)await navigator.clipboard.writeText(n.textContent);else{const i=document.createElement("textarea");i.value=n.textContent,i.style.position="fixed",i.style.left="-999999px",i.style.top="-999999px",document.body.appendChild(i),i.focus(),i.select(),document.execCommand("copy"),i.remove()}e.innerHTML=`
                                <svg class="h-4 w-4 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                                </svg>
                            `,setTimeout(()=>{e.innerHTML=`
                                    <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                                    </svg>
                                `},2e3)}catch(i){console.warn("Failed to copy text: ",i)}})()})})}initSearch(){const t=document.getElementById("docs-search-input"),e=document.getElementById("docs-search-results");if(!t||!e)return;let n=null,s=null;const i=async()=>{if(n)return n;try{const a=await(await fetch("/docs/index.json",{headers:{Accept:"application/json"}})).json();n=new k({fields:["title","heading","content"],storeFields:["slug","title","heading","content","anchor"],searchOptions:{boost:{title:2,heading:1.5,content:1},fuzzy:.2,prefix:!0}}),n.addAll(a)}catch(r){console.warn("Failed to load search index:",r),n=null}return n},c=r=>{if(!r)return"";const a=document.createElement("div");return a.textContent=r,a.innerHTML},d=r=>{if(!r.length){e.classList.add("hidden"),e.innerHTML="";return}e.innerHTML=r.slice(0,8).map(a=>{const u=a.anchor?`/docs/${a.slug}#${a.anchor}`:`/docs/${a.slug}`,h=a.heading?`${a.title} > ${a.heading}`:a.title,f=a.content?a.content.substring(0,100)+"...":"";return`
                <a class="block rounded-md px-3 py-2 text-sm transition-colors hover:bg-gray-100 dark:hover:bg-gray-800" href="${u}">
                    <div class="font-medium text-gray-900 dark:text-white">${c(h)}</div>
                    <div class="mt-1 text-xs text-gray-600 dark:text-gray-400">${c(f)}</div>
                </a>
            `}).join(""),e.classList.remove("hidden")},l=r=>{if(!r.trim()){d([]);return}i().then(a=>{if(!a)return;const u=a.search(r);d(u)})};t.addEventListener("input",r=>{clearTimeout(s),s=setTimeout(()=>l(r.target.value),150)}),t.addEventListener("focus",r=>l(r.target.value)),document.addEventListener("click",r=>{!t.contains(r.target)&&!e.contains(r.target)&&e.classList.add("hidden")})}initTableOfContents(){const t=document.querySelectorAll("[data-toc-link]");if(!t.length)return;const e=Array.from(document.querySelectorAll("h2[id], h3[id]"));if(!e.length)return;let n=!1,s;const i=()=>{if(n)return;const c=window.scrollY,d=window.innerHeight,l=document.documentElement.scrollHeight;let r=null;if(c+d>=l-10)r=e[e.length-1];else for(let a=e.length-1;a>=0;a--){const u=e[a];if(u.getBoundingClientRect().top<=100){r=u;break}}t.forEach(a=>{r&&a.getAttribute("data-toc-link")===r.id?(a.classList.remove("text-gray-600","dark:text-gray-400"),a.classList.add("bg-orange-50","text-orange-700","dark:bg-orange-900/20","dark:text-orange-400")):(a.classList.remove("bg-orange-50","text-orange-700","dark:bg-orange-900/20","dark:text-orange-400"),a.classList.add("text-gray-600","dark:text-gray-400"))})};t.forEach(c=>{c.addEventListener("click",function(d){d.preventDefault();const l=this.getAttribute("data-toc-link"),r=document.getElementById(l);r&&(n=!0,r.scrollIntoView({behavior:"smooth",block:"start"}),history.pushState(null,null,`#${l}`),setTimeout(()=>{n=!1,i()},1e3))})}),window.addEventListener("scroll",function(){clearTimeout(s),s=setTimeout(i,50)},{passive:!0}),i()}initKeyboardShortcuts(){document.addEventListener("keydown",t=>{if((t.metaKey||t.ctrlKey)&&t.key==="k"){t.preventDefault();const e=document.getElementById("docs-search-input");e&&e.focus()}if(t.key==="Escape"){const e=document.getElementById("docs-search-results"),n=document.getElementById("docs-search-input");e&&e.classList.add("hidden"),n&&n.blur()}})}initGlobalLanguageSelector(){const t=document.getElementById("global-lang-select");t&&(this.setCurrentLocaleInSelector(t),t.addEventListener("change",async e=>{const n=e.target.value;try{let s=document.querySelector('meta[name="csrf-token"]')?.getAttribute("content");if(!s){const i=document.cookie.split(";").find(c=>c.trim().startsWith("XSRF-TOKEN="));if(i){s=decodeURIComponent(i.split("=")[1]);try{s=JSON.parse(atob(s)).value}catch(c){console.warn("Could not parse XSRF token:",c)}}}window.location.href=`/locale/${n}?redirect=${encodeURIComponent(window.location.pathname)}`}catch(s){console.error("Error setting locale:",s),e.target.value=document.documentElement.lang.replace("-","_")}}))}setCurrentLocaleInSelector(t){const n=(document.documentElement.lang||"en").split("-")[0];t.querySelector(`option[value="${n}"]`)&&(t.value=n)}}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",()=>new P):new P;
